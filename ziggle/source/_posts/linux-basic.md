---
title: linux-basic
date: 2017-12-08 23:37:31
tags:
    -linux
---


# 重要文件以及位置
- /dev/null  # 输入流blackhole

## /etc/profile
- 系统环境变量,为每个用户设置环境信息,当用户登陆时执行,并从/etc/profile.d 目录的配置文件中搜集shell 的设置.

## /etc/bashrc
- 在执行完/etc/profile 之后如果用户是shell 运行的是bash,就会执行.可以用来设置
每次登陆的时候都会去获取这些新的环境变量或者做某些特殊的操作,但是仅仅在登陆时

## ~/.bashrc
该文件包含专用于单个人的bash shell 的bash 信息,当登录时以及每次打开一个新的shell 时, 该该文件被读取.单个用户此文件的修改会影响到他以后的每一次登陆系统和每一次新开一个bash .因此,可以在这里设置单个用户的特殊的环境变量或者特殊的操作,那么每次它新登陆系统或者新开一个bash ,都会去获取相应的特殊的环境变量和特殊操作

## ~/.bash_logout
当每次退出系统( 退出bash shell) 时, 执行该文件

# shell 基本命令
变量类型
运行shell时,会同时存在三种变量:
- 局部变量 局部变量在脚本或命令中定义,仅在当前shell实例中有效,其他shell启动的程序不能访问局部变量.

- 环境变量 所有的程序,包括shell启动的程序,都能访问环境变量,有些程序需要环境变量来保证其正常运行.必要的时候shell脚本也可以定义环境变量.

- shell变量 shell变量是由shell程序设置的特殊变量.shell变量中有一部分是环境变量,有一部分是局部变量,这些变量保证了shell的正常运行.

查看shell变量
```nil
 root@ziggle:~# env
```
## set

设置bash变量
## unset

清除 本地|系统变量

## exprot

用于把变量变成当前shell 和其子shell 的环境变量,存活期是当前的shell 及其子shell ,因此重新登陆以后,它所设定的环境变量就消失了
## source

<!-- more -->

## 特殊变量

|  变量 |含义   |
| ------------ | ------------ |
| $0  |当前脚本的名字   |
| $n  | 传递给脚本或函数的参数，n是一个数字，表示第几个参数，例如，第一个参数是$1，第二个参数是$2。  |
| $#  | 传递给脚本或函数的参数个数|
| $*  | 传递给脚本或函数的所有参数|
| $@  | 传递给脚本或函数的所有参数。被双引号(“ “)包含时，与 $* 稍有不同|
| $?  |上个命令的退出状态，或函数的返回值 |
| $$  | 当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID|


## 转义字符

```
转义字符	含义
\\	反斜杠
\a	警报，响铃
\b	退格（删除键）
\f	换页(FF)，将当前位置移到下页开头
\n	换行
\r	回车
\t	水平制表符（tab键） 
\v	垂直制表符
```

## 命令替换
命令替换是指Shell可以先执行命令，将输出结果暂时保存，在适当的地方输出。
语法：
```nil
`command`
```ZZ
- eg: 
```bash
#!/bin/bash
DATA=`date`
echo "Date is ${$DATA}"
``` 

# CentOS 升级python3.x
## 源码安装
注意
```
tar Jxvf Python-3.5.1.tar.xz
 cd Python-3.5.1
 ./configure --prefix=/usr/local/python3
 make && make install
```
## 
- 备份旧版本 Python 
```
mv /usr/bin/python /usr/bin/python2.7
```
- 新建指向新版本 Python 以及 pip 的软连接 
```
ln -s /usr/local/python3/bin/python3.5 /usr/bin/python 
ln -s /usr/local/python3/bin/pip3 /usr/bin/pip
```
- 检验 Python 及 pip 版本 
```
python -V 
pip -V
```
> CentOS yum会使用python 更改错误文件python版本为老版本

## 清空文件内容
> 方法1 

```bash
$ > access.log #or
$ true > access.log #or
$ cat /dev/null > access.log # or
$ cp /dev/null  access.log #or
$ echo > access.log
```
> 方法2
```bash
$ truncate -s 0 access.log
```


## source 
当修改 /etc/profile 文件时,立即生效文件
```sh
source filename # 或
. filename
```
source命令通常用于重新执行刚修改的初始化文件，使之立即生效，而不必注销并重新登录

## Linux network config
```conf
pi@raspberrypi:~ $ sudo cat /etc/network/interfaces
# interfaces(5) file used by ifup(8) and ifdown(8)

# Please note that this file is written to be used with dhcpcd
# For static IP, consult /etc/dhcpcd.conf and 'man dhcpcd.conf'

# Include files from /etc/network/interfaces.d:
# source-directory /etc/network/interfaces.d

auto lo

iface lo inet loopback
iface eth0 inet dhcp

allow-hotplug wlan0
iface wlan0 inet manual
wpa-roam /etc/wpa_supplicant/wpa_supplicant.conf
iface default inet static
address 192.168.192.113
netmask 255.255.255.0
gateway 192.168.192.168
```
wpa_supplicant.conf
```conf
pi@raspberrypi:~ $ sudo cat /etc/wpa_supplicant/wpa_supplicant.conf 
country=GB
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
update_config=1

network={
    ssid="wifi-name"
    key_mgmt=WPA-PSK
    psk="12345678"
}
```
### vim plugins
 curl https://j.mp/spf13-vim3 -L > spf13-vim.sh && sh spf13-vim.sh



### 配置DNS 
```conf
  GNU nano 2.7.4                 File: /etc/resolv.conf                            
# Generated by resolvconf
# nameserver 192.168.2.1
nameserver 114.114.114.114
```

### 再环境变量中设置代理
> 配置环境变量
```bash
export http_proxy=http://127.0.0.1:1080
export https_proxy=http://127.0.0.1:1080
```
> 使用配置文件(wget)

为wget配置代理
```nil
~/.wgetrc
# They will override the value in the environment.
 http_proxy=http://127.0.0.1:1080
 https_proxy=http://127.0.0.1:1080
 ftp_proxy=http://127.0.0.1:1080
# If you do not want to use proxy at all, set this to off.
 use_proxy=on
```

top 命令的使用
top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，常用于服务端性能分析。
top 结果分为两个部分
 * 统计信息： 前五行是系统整体的统计信息；
 * 进程信息：统计信息下方类似表格区域显示的是各个进程的详细信息，默认5秒刷新一次。

 {% asset_img top.png top%}


 top 命令选项:

 -b：以批处理模式操作；
-c：显示完整的治命令；
-d：屏幕刷新间隔时间；
-I：忽略失效过程；
-s：保密模式；
-S：累积模式；
-i<时间>：设置间隔时间；
-u<用户名>：指定用户名；
-p<进程号>：指定进程；
-n<次数>：循环显示的次数

 {% asset_img top-keymap.png top_keymap%}


top 命令交互:




# Systemd 使用
> 首先 *ssocks.service*
``` conf
root@ziggle:~# cat /lib/systemd/system/ssocks.service
[Service]
ExecStart=-/usr/local/bin/ssserver -c /etc/shadowsocks.json  start
ExecReload=-/bin/kill -HUP $MAINPID
TimeoutSec=10s
Type=simple
KillMode=process
Restart=always
RestartSec=2s

[Install]
WantedBy=multi-user.target
```
显示所有已启动的服务
> systemctl list-units --type=service
启动某服务
> systemctl start httpd.service
修改配置文件后重启
```sh
# 重新加载配置文件
$ sudo systemctl daemon-reload

# 重启相关服务
$ sudo systemctl restart foobar
```

开机启动
```sh
root@ziggle:~# 
systemctl enable ssocks.service
Created symlink from /etc/systemd/system/multi-user.target.wants/ssocks.service to /lib/systemd/system/ssocks.service.

# 开机禁用
systemctl disable ssocks.service

#查看开机是否启动
systemctl is-enabled ssocks.service #查询服务是否开机启动

# systemd查看开机自启动的程序
ls /etc/systemd/system/multi-user.target.wants/
```

*一旦修改配置文件，就要让 SystemD 重新加载配置文件，然后重新启动，否则修改不会生效。*
```sh
$ sudo systemctl daemon-reload
$ sudo systemctl restart ssocks.service
```

### systemd 系统管理命令
```sh
# 重启系统
$ sudo systemctl reboot

# 关闭系统，切断电源
$ sudo systemctl poweroff

# CPU停止工作
$ sudo systemctl halt

# 暂停系统
$ sudo systemctl suspend

# 让系统进入冬眠状态
$ sudo systemctl hibernate

# 让系统进入交互式休眠状态
$ sudo systemctl hybrid-sleep

# 启动进入救援状态（单用户状态）
$ sudo systemctl rescue
```

## 配置文件的区块
```conf
Description：简短描述
Documentation：文档地址
Requires：当前 Unit 依赖的其他 Unit，如果它们没有运行，当前 Unit 会启动失败
Wants：与当前 Unit 配合的其他 Unit，如果它们没有运行，当前 Unit 不会启动失败
BindsTo：与Requires类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行
Before：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动
After：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之前启动
Conflicts：这里指定的 Unit 不能与当前 Unit 同时运行
Condition：当前 Unit 运行必须满足的条件，否则不会运行
Assert：当前 Unit 运行必须满足的条件，否则会报启动失败

```

* [Service]区块用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段如下。*
```
Type：定义启动时的进程行为。它有以下几种值。
Type=simple：默认值，执行ExecStart指定的命令，启动主进程
Type=forking：以 fork 方式从父进程创建子进程，创建后父进程会立即退出
Type=oneshot：一次性进程，Systemd 会等当前服务退出，再继续往下执行
Type=dbus：当前服务通过D-Bus启动
Type=notify：当前服务启动完毕，会通知Systemd，再继续往下执行
Type=idle：若有其他任务执行完毕，当前服务才会运行
ExecStart：启动当前服务的命令
ExecStartPre：启动当前服务之前执行的命令
ExecStartPost：启动当前服务之后执行的命令
ExecReload：重启当前服务时执行的命令
ExecStop：停止当前服务时执行的命令
ExecStopPost：停止当其服务之后执行的命令
RestartSec：自动重启当前服务间隔的秒数
Restart：定义何种情况 Systemd 会自动重启当前服务，可能的值包括always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog
TimeoutSec：定义 Systemd 停止当前服务之前等待的秒数
Environment：指定环境变量
```

ref : http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html

sh 使用公钥连接

```sh
ssh -i ~/.ssh/my-ssh-key [USERNAME]@[EXTERNAL_IP_ADDRESS]
```

wsl 连接配置

装上 ubuntu on windows 后，默认要先打开 cmd, 再运行 bash 进入 ubuntu 的 shell。 
但是这个shell很难看，配色不好就算了，还存在各种复制粘贴麻烦、默认没进入 home 目录、各种报警声等问题。所以尝试用 xshell 登陆 ubuntu 
这里主要讲几个关键步骤

1. 卸载 ssh server

sudo apt-get remove openssh-server

2. 安装 ssh server

sudo apt-get install openssh-server

3. 修改 ssh server 配置


sudo vim /etc/ssh/sshd_config
需要修改以下几项：

Port 2222  #默认的是22，但是windows有自己的ssh服务，也是监听的22端口，所以这里要改一下
UsePrivilegeSeparation no
PasswordAuthentication yes
AllowUsers youusername # 这里改成你登陆WSL用的

4. 启动 ssh server
 
sudo service ssh --full-restart
现在就可以用 xshell 登陆 ubuntu on windows 了，IP 是 127.0.0.1, 但是要注意，cmd 的窗口还不能关掉。关掉后 sshd 服务也会关掉，连接就断开了。这个问题目前还没找到解决办法。


rpm -ivh jdk-10.interim.update.patch_linux-x64_bin.rpm